#   bash_completion - programmable completion functions for bash 3.x
#		      (backwards compatible with bash 2.05b)
#
#   $Id: bash_completion,v 1.872 2006/03/01 16:20:18 ianmacd Exp $
#
#   Copyright (C) Ian Macdonald <ian@caliban.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   The latest version of this software can be obtained here:
#
#   http://www.caliban.org/bash/index.shtml#completion
#
#   RELEASE: 20060301

[ -n "${BASH_COMPLETION_DEBUG:-}" ] && set -v || set +v

# Alter the following to reflect the location of this file.
#
{
  # These declarations must go within braces in order to be able to silence
  # readonly variable errors.
  BASH_COMPLETION="${BASH_COMPLETION:-/etc/bash_completion}"
  BASH_COMPLETION_DIR="${BASH_COMPLETION_DIR:=/etc/bash_completion.d}"
} 2>/dev/null || :
readonly BASH_COMPLETION BASH_COMPLETION_DIR

# Set a couple of useful vars
#
UNAME=$( uname -s )
# strip OS type and version under Cygwin (e.g. CYGWIN_NT-5.1 => Cygwin)
UNAME=${UNAME/CYGWIN_*/Cygwin}
RELEASE=$( uname -r )

# features supported by bash 2.05 and higher
if [ ${BASH_VERSINFO[0]} -eq 2 ] && [[ ${BASH_VERSINFO[1]} > 04 ]] ||
   [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash205=$BASH_VERSION 2>/dev/null || :
	default="-o default"
	dirnames="-o dirnames"
	filenames="-o filenames"
fi
# features supported by bash 2.05b and higher
if [ ${BASH_VERSINFO[0]} -eq 2 ] && [[ ${BASH_VERSINFO[1]} = "05b" ]] ||
   [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash205b=$BASH_VERSION 2>/dev/null || :
	nospace="-o nospace"
fi
# features supported by bash 3.0 and higher
if [ ${BASH_VERSINFO[0]} -gt 2 ]; then
	declare -r bash3=$BASH_VERSION 2>/dev/null || :
	bashdefault="-o bashdefault"
	plusdirs="-o plusdirs"
fi

# Turn on extended globbing and programmable completion
shopt -s extglob progcomp

# A lot of the following one-liners were taken directly from the
# completion examples provided with the bash 2.04 source distribution

# Make directory commands see only directories
complete -d pushd

# The following section lists completions that are redefined later
# Do NOT break these over multiple lines.
#
# START exclude -- do NOT remove this line
complete -f -X '!*.?(t)bz?(2)' bunzip2 bzcat bzcmp bzdiff bzegrep bzfgrep bzgrep
complete -f -X '!*.@(zip|ZIP|jar|JAR|exe|EXE|pk3|war|wsz|ear|zargo|xpi|sxw|ott)' unzip zipinfo
complete -f -X '*.Z' compress znew
complete -f -X '!*.@(Z|gz|tgz|Gz|dz)' gunzip zcmp zdiff zcat zegrep zfgrep zgrep zless zmore
complete -f -X '!*.Z' uncompress
complete -f -X '!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX)' ee display
complete -f -X '!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|GIF|JPG|JP?(E)G|TIF?(F)|PNG|P[BGP]M|BMP|X[BP]M|RLE|RGB|PCX|FITS|PM)' xv qiv
complete -f -X '!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))' gv ggv kghostview
complete -f -X '!*.@(dvi|DVI)?(.@(gz|Z|bz2))' xdvi
complete -f -X '!*.@(dvi|DVI)' dvips dviselect dvitype kdvi dvipdf advi
complete -f -X '!*.@(pdf|PDF)' acroread gpdf xpdf kpdf
complete -f -X '!*.@(@(?(e)ps|?(E)PS)?(.gz|.GZ)|pdf|PDF|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX)' evince
complete -f -X '!*.@(?(e)ps|?(E)PS)' ps2pdf
complete -f -X '!*.texi*' makeinfo texi2html
complete -f -X '!*.@(?(la)tex|?(LA)TEX|texi|TEXI|dtx|DTX|ins|INS)' tex latex slitex jadetex pdfjadetex pdftex pdflatex texi2dvi
complete -f -X '!*.@(mp3|MP3)' mpg123 mpg321 madplay
complete -f -X '!*.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|vcd|ps|pes|fli|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp3|MP3|ogg|OGG|ogm|OGM|mp4|MP4|wav|WAV|asx|ASX|mng|MNG)' xine aaxine fbxine kaffeine
complete -f -X '!*.@(avi|asf|wmv)' aviplay
complete -f -X '!*.@(rm?(j)|ra?(m)|smi?(l))' realplay
complete -f -X '!*.@(mpg|mpeg|avi|mov|qt)' xanim
complete -f -X '!*.@(ogg|OGG|m3u|flac|spx)' ogg123
complete -f -X '!*.@(mp3|MP3|ogg|OGG|pls|m3u)' gqmpeg freeamp
complete -f -X '!*.fig' xfig
complete -f -X '!*.@(mid?(i)|MID?(I))' playmidi
complete -f -X '!*.@(mid?(i)|MID?(I)|rmi|RMI|rcp|RCP|[gr]36|[GR]36|g18|G18|mod|MOD|xm|XM|it|IT|x3m|X3M)' timidity
complete -f -X '*.@(o|so|so.!(conf)|a|t@(ar?(.@(Z|gz|bz?(2)))|gz|bz?(2))|rpm|zip|ZIP|gif|GIF|jp?(e)g|JP?(E)G|mp3|MP3|mp?(e)g|MPG|avi|AVI|asf|ASF|ogg|OGG|class|CLASS)' vi vim gvim rvim view rview rgvim rgview gview
complete -f -X '*.@(o|so|so.!(conf)|a|rpm|gif|GIF|jp?(e)g|JP?(E)G|mp3|MP3|mp?(e)g|MPG|avi|AVI|asf|ASF|ogg|OGG|class|CLASS)' emacs
complete -f -X '!*.@(exe|EXE|com|COM|scr|SCR|exe.so)' wine
complete -f -X '!*.@(zip|ZIP|z|Z|gz|GZ|tgz|TGZ)' bzme
complete -f -X '!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))' netscape mozilla lynx opera galeon curl dillo elinks amaya
complete -f -X '!*.@(sxw|stw|sxg|sgl|doc|dot|rtf|txt|htm|html|odt|ott|odm)' oowriter
complete -f -X '!*.@(sxi|sti|pps|ppt|pot|odp|otp)' ooimpress
complete -f -X '!*.@(sxc|stc|xls|xlw|xlt|csv|ods|ots)' oocalc
complete -f -X '!*.@(sxd|std|sda|sdd|odg|otg)' oodraw
complete -f -X '!*.@(sxm|smf|mml|odf)' oomath
complete -f -X '!*.odb' oobase
complete -f -X '!*.rpm' rpm2cpio
# FINISH exclude -- do not remove this line

# start of section containing compspecs that can be handled within bash

# user commands see only users
complete -u su usermod userdel passwd chage write chfn groups slay w

# group commands see only groups
[ -n "$bash205" ] && complete -g groupmod groupdel newgrp 2>/dev/null

# bg completes with stopped jobs
complete -A stopped -P '%' bg

# other job commands
complete -j -P '%' fg jobs disown

# readonly and unset complete with shell variables
complete -v readonly unset

# set completes with set options
complete -A setopt set

# shopt completes with shopt options
complete -A shopt shopt

# helptopics
complete -A helptopic help

# unalias completes with aliases
complete -a unalias

# bind completes with readline bindings (make this more intelligent)
complete -A binding bind

# type and which complete on commands
complete -c command type which

# builtin completes on builtins
complete -b builtin

# start of section containing completion functions called by other functions

# This function checks whether we have a given program on the system.
# No need for bulky functions in memory if we don't.
#
have()
{
	unset -v have
	PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin type $1 &>/dev/null &&
		have="yes"
}

# use GNU sed if we have it, since its extensions are still used in our code
#
[ $UNAME != Linux ] && have gsed && alias sed=gsed

# This function checks whether a given readline variable
# is `on'.
#
_rl_enabled() 
{
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}


# This function performs file and directory completion. It's better than
# simply using 'compgen -f', because it honours spaces in filenames.
# If passed -d, it completes only on directories. If passed anything else,
# it's assumed to be a file glob to complete on.
#
_filedir()
{
	local IFS=$'\t\n' xspec #glob

	_expand || return 0

	#glob=$(set +o|grep noglob) # save glob setting.
	#set -f		 # disable pathname expansion (globbing)

	if [ "${1:-}" = -d ]; then
		COMPREPLY=( ${COMPREPLY[@]:-} $( compgen -d -- $cur ) )
		#eval "$glob"    # restore glob setting.
		return 0
	fi

	xspec=${1:+"!*.$1"}	# set only if glob passed in as $1
	COMPREPLY=( ${COMPREPLY[@]:-} $( compgen -f -X "$xspec" -- "$cur" ) \
		    $( compgen -d -- "$cur" ) )
	#eval "$glob"    # restore glob setting.
}

# This function completes on signal names
#
_signals()
{
	local i

	# standard signal completion is rather braindead, so we need
	# to hack around to get what we want here, which is to
	# complete on a dash, followed by the signal name minus
	# the SIG prefix
	COMPREPLY=( $( compgen -A signal SIG${cur#-} ))
	for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
		COMPREPLY[i]=-${COMPREPLY[i]#SIG}
	done
}

# This function completes on configured network interfaces
#
_configured_interfaces()
{
	if [ -f /etc/debian_version ]; then
		# Debian system
		COMPREPLY=( $( sed -ne 's|^iface \([^ ]\+\).*$|\1|p' \
			       /etc/network/interfaces ) )
	elif [ -f /etc/SuSE-release ]; then
		# SuSE system
		COMPREPLY=( $( command ls \
			/etc/sysconfig/network/ifcfg-* | \
			sed -ne 's|.*ifcfg-\('$cur'.*\)|\1|p' ) )
	elif [ -f /etc/pld-release ]; then
		# PLD Linux
		COMPREPLY=( $( command ls -B \
			/etc/sysconfig/interfaces | \
			sed -ne 's|.*ifcfg-\('$cur'.*\)|\1|p' ) )
	else
		# Assume Red Hat
		COMPREPLY=( $( command ls \
			/etc/sysconfig/network-scripts/ifcfg-* | \
			sed -ne 's|.*ifcfg-\('$cur'.*\)|\1|p' ) )
	fi
}

# This function completes on all available network interfaces
# -a: restrict to active interfaces only
# -w: restrict to wireless interfaces only
#
_available_interfaces()
{
	local cmd

	if [ "${1:-}" = -w ]; then
		cmd="iwconfig"
	elif [ "${1:-}" = -a ]; then
		cmd="ifconfig"
	else
		cmd="ifconfig -a"
	fi

	COMPREPLY=( $( eval $cmd 2>/dev/null | \
		sed -ne 's|^\('$cur'[^[:space:][:punct:]]\{1,\}\).*$|\1|p') )
}

# This function expands tildes in pathnames
#
_expand()
{
	[ "$cur" != "${cur%\\}" ] && cur="$cur\\"

	# expand ~username type directory specifications
	if [[ "$cur" == \~*/* ]]; then
		eval cur=$cur
		
	elif [[ "$cur" == \~* ]]; then
		cur=${cur#\~}
		COMPREPLY=( $( compgen -P '~' -u $cur ) )
		return ${#COMPREPLY[@]}
	fi
}

# This function completes on process IDs.
# AIX and Solaris ps prefers X/Open syntax.
[ $UNAME = SunOS -o $UNAME = AIX ] &&
_pids()
{
	COMPREPLY=( $( compgen -W '$( command ps -efo pid | sed 1d )' -- $cur ))
} ||
_pids()
{
	COMPREPLY=( $( compgen -W '$( command ps axo pid | sed 1d )' -- $cur ) )
}

# This function completes on process group IDs.
# AIX and SunOS prefer X/Open, all else should be BSD.
[ $UNAME = SunOS -o $UNAME = AIX ] &&
_pgids()
{
	COMPREPLY=( $( compgen -W '$( command ps -efo pgid | sed 1d )' -- $cur ))
} ||
_pgids()
{
	COMPREPLY=( $( compgen -W '$( command ps axo pgid | sed 1d )' -- $cur ))
}

# This function completes on user IDs
#
_uids()
{
	if type getent &>/dev/null; then
	    COMPREPLY=( $( getent passwd | \
			    awk -F: '{if ($3 ~ /^'$cur'/) print $3}' ) )
	elif type perl &>/dev/null; then
	    COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- $cur ) )
	else
	    # make do with /etc/passwd
	    COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($3 ~ /^'$cur'/) print $3}'\
			    /etc/passwd ) )
	fi
}

# This function completes on group IDs
#
_gids()
{
	if type getent &>/dev/null; then
	    COMPREPLY=( $( getent group | \
			    awk -F: '{if ($3 ~ /^'$cur'/) print $3}' ) )
	elif type perl &>/dev/null; then
	    COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- $cur ) )
	else
	    # make do with /etc/group
	    COMPREPLY=( $( awk 'BEGIN {FS=":"} {if ($3 ~ /^'$cur'/) print $3}'\
			    /etc/group ) )
	fi
}

# This function completes on services
#
_services()
{
	local sysvdir famdir
	[ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d
	famdir=/etc/xinetd.d
	COMPREPLY=( $( builtin echo $sysvdir/!(*.rpmsave|*.rpmorig|*~|functions)) )

	if [ -d $famdir ]; then
		COMPREPLY=( ${COMPREPLY[@]} $( builtin echo $famdir/!(*.rpmsave|*.rpmorig|*~)) )
	fi

	COMPREPLY=( $( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- $cur ) )
}

# This function complete on modules
#
_modules()
{
	local modpath
	modpath=/lib/modules/$1
	COMPREPLY=( $( command ls -R $modpath | \
			sed -ne 's/^\('$cur'.*\)\.k\?o\(\|.gz\)$/\1/p') )
}

# this function complete on user:group format
#
_usergroup()
{
	local IFS=$'\n'
	cur=${cur//\\\\ / }
	if [[ $cur = *@(\\:|.)* ]] && [ -n "$bash205" ]; then
		user=${cur%%*([^:.])}
		COMPREPLY=( $(compgen -P ${user/\\\\} -g -- ${cur##*[.:]}) )
	elif [[ $cur = *:* ]] && [ -n "$bash205" ]; then
		COMPREPLY=( $( compgen -g -- ${cur##*[.:]} ) )
	else
		COMPREPLY=( $( compgen -S : -u -- $cur ) )
	fi
}

# this function count the number of mandatory args
#
_count_args()
{
	args=1
	for (( i=1; i < COMP_CWORD; i++ )); do
		if [[ "${COMP_WORDS[i]}" != -* ]]; then
			args=$(($args+1))
		fi
	done
}

# start of section containing completion functions for bash built-ins

# bash alias completion
#
_alias()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[$COMP_CWORD]}

	case "$COMP_LINE" in
	*[^=])
		COMPREPLY=( $( compgen -A alias -S '=' -- $cur ) )
		;;
	*=)
		COMPREPLY=( "$( alias ${cur%=} 2>/dev/null | \
			     sed -e 's|^alias '$cur'\(.*\)$|\1|' )" )
		;;
	esac
}
complete -F _alias $nospace alias

# bash export completion
#
_export()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[$COMP_CWORD]}

	case "$COMP_LINE" in
	*=\$*)
		COMPREPLY=( $( compgen -v -P '$' -- ${cur#*=\$} ) )
		;;
	*[^=])
		COMPREPLY=( $( compgen -v -S '=' -- $cur ) )
		;;
	*=)
		COMPREPLY=( "$( eval echo -n \"$`echo ${cur%=}`\" |
			( echo -n \'
			  sed -e 's/'\''/'\''\\\'\'''\''/g'
			  echo -n \' ) )" )
		;;
	esac
}
complete -F _export $default $nospace export

# bash shell function completion
#
_function()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	if [[ $1 == @(declare|typeset) ]]; then
		if [ "$prev" = -f ]; then
			COMPREPLY=( $( compgen -A function -- $cur ) )
		elif [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '-a -f -F -i -r -x -p' -- \
				       $cur ) )
		fi
	elif [ $COMP_CWORD -eq 1 ]; then
		COMPREPLY=( $( compgen -A function -- $cur ) )
	else
		COMPREPLY=( "() $( type -- ${COMP_WORDS[1]} | sed -e 1,2d )" )
	fi
}
complete -F _function function declare typeset

# bash complete completion
#
_complete()
{
	local cur prev options

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case $prev in
		-o)
			options="default dirnames filenames"
			[ -n "$bash205b" ] && options="$options nospace"
			[ -n "$bash3" ] && options="$options bashdefault plusdirs"
			COMPREPLY=( $( compgen -W "$options" -- $cur ) )
			return 0
			;;

		-A)
			COMPREPLY=( $( compgen -W 'alias arrayvar binding \
				builtin command directory disabled enabled \
				export file function group helptopic hostname \
				job keyword running service setopt shopt \
				signal stopped user variable' -- $cur ) )
			return 0
			;;

		-C)
			COMPREPLY=( $( compgen -A command -- $cur ) )
			return 0
			;;
		-F)
			COMPREPLY=( $( compgen -A function -- $cur ) )
			return 0
			;;
		-@(p|r))
			COMPREPLY=( $( complete -p | sed -e 's|.* ||' | \
					grep "^$cur" ) )
			return 0
			;;

	esac

	if [[ "$cur" == -* ]]; then
		# relevant options completion
		options="-a -b -c -d -e -f -g -j -k -s -v -u -A -G -W -P -S -X -F -C"
		[ -n "$bash205" ] && options="$options -o"
		COMPREPLY=( $( compgen -W "$options" -- $cur ) )
	else
		COMPREPLY=( $( compgen -A command -- $cur ) )
	fi
}
complete -F _complete complete

# start of section containing completion functions for external programs

# a little help for FreeBSD ports users
[ $UNAME = FreeBSD ] && complete -W 'index search fetch fetch-list \
	extract patch configure build install reinstall \
	deinstall clean clean-depends kernel buildworld' make

# This completes on a list of all available service scripts for the
# 'service' command and/or the SysV init.d directory, followed by
# that script's available commands
#
{ have service || [ -d /etc/init.d/ ]; } &&
_service()
{
	local cur sysvdir

	COMPREPLY=()
	prev=${COMP_WORDS[COMP_CWORD-1]}
	cur=${COMP_WORDS[COMP_CWORD]}

	# don't complete for things like killall, ssh and mysql if it's
	# the standalone command, rather than the init script
	[[ ${COMP_WORDS[0]} != @(*init.d/!(functions|~)|service) ]] && return 0

	# don't complete past 2nd token
	[ $COMP_CWORD -gt 2 ] && return 0

	[ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d \
				|| sysvdir=/etc/init.d

	if [[ $COMP_CWORD -eq 1 ]] && [[ $prev == "service" ]]; then
		_services
	else
		COMPREPLY=( $( compgen -W '`sed -ne "y/|/ /; \
				s/^.*Usage.*{\(.*\)}.*$/\1/p" \
				$sysvdir/${prev##*/} 2>/dev/null`' -- $cur ) )
	fi

	return 0
} &&
complete -F _service service
[ -d /etc/init.d/ ] && complete -F _service $default \
	$(for i in /etc/init.d/*; do echo ${i##*/}; done)

# umount(8) completion. This relies on the mount point being the third
# space-delimited field in the output of mount(8)
#
_umount()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	COMPREPLY=( $( compgen -W '$( mount | cut -d" " -f 3 )' -- $cur ) )

	return 0
}
complete -F _umount $dirnames umount

# mount(8) completion. This will pull a list of possible mounts out of
# /etc/{,v}fstab, unless the word being completed contains a ':', which
# would indicate the specification of an NFS server. In that case, we
# query the server for a list of all available exports and complete on
# that instead.
#
_mount()
{       local cur i sm host

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	[[ "$cur" == \\ ]] && cur="/"

	for i in {,/usr}/{,s}bin/showmount; do [ -x $i ] && sm=$i && break; done

	if [ -n "$sm" ] && [[ "$cur" == *:* ]]; then
		COMPREPLY=( $( $sm -e ${cur%%:*} | sed 1d | \
			       grep ^${cur#*:} | awk '{print $1}' ) )
	elif [[ "$cur" == //* ]]; then
		host=${cur#//}
		host=${host%%/*}
		if [ -n "$host" ]; then
			COMPREPLY=( $( compgen -W "$( echo $( smbclient -d 0 -NL $host 2>/dev/null|
			sed -ne '/^['"$'\t '"']*Sharename/,/^$/p' |
			sed -ne '3,$s|^[^A-Za-z]*\([^'"$'\t '"']*\).*$|//'$host'/\1|p' ) )" -- "$cur" ) )
		fi
	elif [ -r /etc/vfstab ]; then
		# Solaris
		COMPREPLY=( $( awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' \
				/etc/vfstab | grep "^$cur" ) )
	elif [ ! -e /etc/fstab ]; then
		# probably Cygwin
		COMPREPLY=( $( mount | awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' \
				 | grep "^$cur" ) )
	else
		# probably Linux
		COMPREPLY=( $( awk '! /^[ \t]*#/ {if ($2 ~ /\//) print $2}' \
				/etc/fstab | grep "^$cur" ) )
	fi

	return 0
}
complete -F _mount $default $filenames mount

# renice(8) completion
#
_renice()
{
	local command cur curopt i

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	command=$1

	i=0
	# walk back through command line and find last option
	while [ $i -le $COMP_CWORD -a ${#COMPREPLY[@]} -eq 0 ]; do
		curopt=${COMP_WORDS[COMP_CWORD-$i]}
		case "$curopt" in
		-u)
			COMPREPLY=( $( compgen -u -- $cur ) )
			;;
		-g)
			_pgids
			;;
		-p|$command)
			_pids
			;;
		esac
		i=$(( ++i ))
	done
}
complete -F _renice renice

# kill(1) completion
#
_kill()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [ $COMP_CWORD -eq 1 ] && [[ "$cur" == -* ]]; then
		# return list of available signals
		_signals
	else
		# return list of available PIDs
		_pids
	fi
}
complete -F _kill kill

# Linux and FreeBSD killall(1) completion.
#
[ $UNAME = Linux -o $UNAME = FreeBSD ] &&
_killall()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [ $COMP_CWORD -eq 1 ] && [[ "$cur" == -* ]]; then
		_signals
	else
		COMPREPLY=( $( compgen -W '$( command ps axo command | \
			      sed -ne "1d; s/^\[\?\([^-][^] ]*\).*$/\1/p" | \
			      sed -e "s/.*\///" )' -- $cur ) )
	fi

	return 0
}
[ $UNAME = Linux -o $UNAME = FreeBSD ] && complete -F _killall killall pkill

# Linux and FreeBSD pgrep(1) completion.
#
[ $UNAME = Linux -o $UNAME = FreeBSD ] &&
_pgrep()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	COMPREPLY=( $( compgen -W '$( command ps axo command | \
		      sed -ne "1d; s/^\[\?\([^-][^] ]*\).*$/\1/p" | \
		      sed -e "s/.*\///" )' -- $cur ) )

	return 0
}
[ $UNAME = Linux -o $UNAME = FreeBSD ] && complete -F _pgrep pgrep
# Linux pidof(8) completion.
[ $UNAME = Linux ] && complete -F _pgrep pidof

# GNU find(1) completion. This makes heavy use of ksh style extended
# globs and contains Linux specific code for completing the parameter
# to the -fstype option.
#
_find()
{
	local cur prev i exprfound onlyonce

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
	-@(max|min)depth)
		COMPREPLY=( $( compgen -W '0 1 2 3 4 5 6 7 8 9' -- $cur ) )
		return 0
		;;
	-?(a|c)newer|-fls|-fprint?(0|f)|-?(i)?(l)name)
		_filedir
		return 0
		;;
	-fstype)
		# this is highly non-portable
		[ -e /proc/filesystems ] &&
		COMPREPLY=( $( cut -d$'\t' -f 2 /proc/filesystems | \
				grep "^$cur" ) )
		return 0
		;;
	-gid)
		_gids
		return 0
		;;
	-group)
		if [ -n "$bash205" ]; then
			COMPREPLY=( $( compgen -g -- $cur 2>/dev/null) )
		fi
		return 0
		;;
	-?(x)type)
		COMPREPLY=( $( compgen -W 'b c d p f l s' -- $cur ) )
		return 0
		;;
	-uid)
		_uids
		return 0
		;;
	-user)
		COMPREPLY=( $( compgen -u -- $cur ) )
		return 0
		;;
	-exec|-ok)
		COMP_WORDS=(COMP_WORDS[0] $cur)
		COMP_CWORD=1
		_command
		return 0
		;;
	-[acm]min|-[acm]time|-?(i)?(l)name|-inum|-?(i)path|-?(i)regex| \
	-links|-perm|-size|-used|-printf)
		# do nothing, just wait for a parameter to be given
		return 0
		;;
	esac

	_expand || return 0

	# set exprfound to 1 if there is already an expression present
	for i in ${COMP_WORDS[@]}; do
		[[ "$i" = [-\(\),\!]* ]] && exprfound=1 && break
	done

	# handle case where first parameter is not a dash option
	if [ "$exprfound" != 1 ] && [[ "$cur" != [-\(\),\!]* ]]; then
		_filedir -d
		return 0
	fi

	# complete using basic options
	COMPREPLY=( $( compgen -W '-daystart -depth -follow -help -maxdepth \
			-mindepth -mount -noleaf -version -xdev -amin -anewer \
			-atime -cmin -cnewer -ctime -empty -false -fstype \
			-gid -group -ilname -iname -inum -ipath -iregex \
			-links -lname -mmin -mtime -name -newer -nouser \
			-nogroup -perm -regex -size -true -type -uid -used \
			-user -xtype -exec -fls -fprint -fprint0 -fprintf -ok \
			-print -print0 -printf -prune -ls' -- $cur ) )

	# this removes any options from the list of completions that have
	# already been specified somewhere on the command line, as long as
	# these options can only be used once (in a word, "options", in
	# opposition to "tests" and "actions", as in the find(1) manpage).
	onlyonce=' -daystart -depth -follow -help -maxdepth -mindepth -mount \
		   -noleaf -version -xdev '
	COMPREPLY=( $( echo "${COMP_WORDS[@]}" | \
		       (while read -d ' ' i; do
			    [ "$i" == "" ] ||
			    [ "${onlyonce/ ${i%% *} / }" == "$onlyonce" ] &&
			    continue
			    # flatten array with spaces on either side,
			    # otherwise we cannot grep on word boundaries of
			    # first and last word
			    COMPREPLY=" ${COMPREPLY[@]} "
			    # remove word from list of completions
			    COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
			done
			echo ${COMPREPLY[@]})
		  ) )
	
	_filedir
	
	return 0
}
complete -F _find $filenames find

# Linux iwconfig(8) completion
#
[ $UNAME = Linux ] && have iwconfig &&
_iwconfig()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}
	
	case $prev in
		mode)
			COMPREPLY=( $( compgen -W 'managed ad-hoc master \
				repeater secondary monitor' -- $cur ) )
			return 0
			;;
		essid)
			COMPREPLY=( $( compgen -W 'on off any' -- $cur ) )
			if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
				COMPREPLY=( ${COMPREPLY[@]:-} \
					$( iwlist ${COMP_WORDS[1]} scan | \
					awk -F '"' '/ESSID/ {print $2}' | \
					grep "^$cur" ))
			fi
			return 0
			;;
		nwid)
			COMPREPLY=( $( compgen -W 'on off' -- $cur ) )
			return 0
			;;
		channel)
			COMPREPLY=( $( iwlist ${COMP_WORDS[1]} channel | \
				awk '/^[[:space:]]*Channel/ {print $2}' | \
				grep "^$cur" ) )
			return 0
			;;

		freq)
			COMPREPLY=( $( iwlist ${COMP_WORDS[1]} channel | \
				awk '/^[[:space:]]*Channel/ {print $4"G"}' | \
				grep "^$cur" ) )
			return 0
			;;
		ap)
			COMPREPLY=( $( compgen -W 'on off any' -- $cur ) )
			if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
				COMPREPLY=( ${COMPREPLY[@]:-} \
					$( iwlist ${COMP_WORDS[1]} scan | \
					awk -F ': ' '/Address/ {print $2}' | \
					grep "^$cur" ) )
			fi
			return 0
			;;
		rate)
			COMPREPLY=( $( compgen -W 'auto fixed' -- $cur ) )
			COMPREPLY=( ${COMPREPLY[@]:-} \
				$( iwlist ${COMP_WORDS[1]} rate | \
				awk '/^[[:space:]]*[0-9]/ {print $1"M"}' | \
				grep "^$cur" ) )
			return 0
			;;
		rts)
			COMPREPLY=( $( compgen -W 'auto fixed off' -- $cur ) )
			return 0
			;;
		frag)
			COMPREPLY=( $( compgen -W 'auto fixed off' -- $cur ) )
			return 0
			;;
		key)
			COMPREPLY=( $( compgen -W 'off on open restricted' -- $cur ) )
			return 0
			;;
		enc)
			COMPREPLY=( $( compgen -W 'off on open restricted' -- $cur ) )
			return 0
			;;
		power)
			COMPREPLY=( $( compgen -W 'period timeout off on' -- $cur ) )
			return 0
			;;
		txpower)
			COMPREPLY=( $( compgen -W 'off on auto' -- $cur ) )
			return 0
			;;
		retry)
			COMPREPLY=( $( compgen -W 'limit lifetime' -- $cur ) )
			return 0
			;;
	esac

	if [ $COMP_CWORD -eq 1 ]; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--help --version' -- $cur ) ) 
		else
			_available_interfaces -w
		fi
	else
		COMPREPLY=( $( compgen -W 'essid nwid mode freq channel sens mode \
			ap nick rate rts frag enc key power txpower commit' -- $cur ) ) 
	fi

} &&
complete -F _iwconfig iwconfig

# Linux iwlist(8) completion
#
[ $UNAME = Linux ] && have iwlist &&
_iwlist()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}
	
	if [ $COMP_CWORD -eq 1 ]; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--help --version' -- $cur ) ) 
		else
			_available_interfaces -w
		fi
	else
		COMPREPLY=( $( compgen -W 'scan scanning freq frequency \
			channel rate bit bitrate key enc encryption power \
			txpower retry ap accesspoint peers event' -- $cur ) ) 
	fi
} &&
complete -F _iwlist iwlist

# Linux iwspy(8) completion
#
[ $UNAME = Linux ] && have iwspy &&
_iwspy()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [ $COMP_CWORD -eq 1 ]; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--help --version' -- $cur ) ) 
		else
			_available_interfaces -w
		fi
	else
		COMPREPLY=( $( compgen -W 'setthr getthr off' -- $cur ) ) 
	fi
} &&
complete -F _iwspy iwspy

# Linux iwpriv(8) completion
#
[ $UNAME = Linux ] && have iwpriv &&
_iwpriv()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
		roam)
			COMPREPLY=( $( compgen -W 'on off' -- $cur ) )
			return 0
			;;
		port)
			COMPREPLY=( $( compgen -W 'ad-hoc managed' -- $cur ) )
			return 0
			;;
	esac

	if [ $COMP_CWORD -eq 1 ]; then
		if [[ "$cur" == -* ]]; then
			COMPREPLY=( $( compgen -W '--help --version' -- $cur ) ) 
		else
			_available_interfaces -w
		fi
	else
		COMPREPLY=( $( compgen -W '--all roam port' -- $cur ) ) 
	fi
} &&
complete -F _iwpriv iwpriv

# This function provides simple user@host completion
#
_user_at_host() {
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [[ $cur == *@* ]]; then
		_known_hosts
	else
		COMPREPLY=( $( compgen -u -- "$cur" ) )
	fi

	return 0
}
shopt -u hostcomplete && complete -F _user_at_host $nospace talk ytalk finger

# This function performs host completion based on ssh's known_hosts files,
# defaulting to standard host completion if they don't exist.
#
_known_hosts()
{
       local cur curd ocur user suffix aliases global_kh user_kh hosts i host
       local -a kh khd config

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	ocur=$cur

	[ "$1" = -a ] || [ "$2" = -a ] && aliases='yes'
	[ "$1" = -c ] || [ "$2" = -c ] && suffix=':'
	[[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@}
	kh=()

	# ssh config files
	[ -r /etc/ssh/ssh_config ] &&
	  config=( ${config[@]} /etc/ssh/ssh_config )
	[ -r ~/.ssh/config ] &&
	  config=( ${config[@]} ~/.ssh/config )
	[ -r ~/.ssh2/config ] &&
	  config=( ${config[@]} ~/.ssh2/config )

	if [ ${#config[@]} -gt 0 ]; then
	    # expand path (if present) to global known hosts file
	    global_kh=$( eval echo $( sed -ne 's/^[Gg][Ll][Oo][Bb][Aa][Ll][Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee]['"$'\t '"']*\(.*\)$/\1/p' ${config[@]} ) )
	    # expand path (if present) to user known hosts file
	    user_kh=$( eval echo $( sed -ne 's/^[Uu][Ss][Ee][Rr][Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee]['"$'\t '"']*\(.*\)$/\1/p' ${config[@]} ) )
	fi

	# choose which global known hosts file to use
	if [ -r "$global_kh" ]; then
	    kh=( "$global_kh" )
	else
	    [ -r /etc/ssh/ssh_known_hosts ] &&
	      kh=( ${kh[@]} /etc/ssh/ssh_known_hosts )
	    [ -r /etc/ssh/ssh_known_hosts2 ] &&
	      kh=( ${kh[@]} /etc/ssh/ssh_known_hosts2 )
	    [ -r /etc/known_hosts ] &&
	      kh=( ${kh[@]} /etc/known_hosts )
	    [ -r /etc/known_hosts2 ] &&
	      kh=( ${kh[@]} /etc/known_hosts2 )
	    [ -d /etc/ssh2/knownhosts ] &&
	      khd=( ${khd[@]} /etc/ssh2/knownhosts/*pub )
	fi

	# choose which user known hosts file to use
	if [ -r "$user_kh" ]; then
	    kh=( ${kh[@]} "$user_kh" )
	else
	    [ -r ~/.ssh/known_hosts ] &&
	      kh=( ${kh[@]} ~/.ssh/known_hosts )
	    [ -r ~/.ssh/known_hosts2 ] &&
	      kh=( ${kh[@]} ~/.ssh/known_hosts2 )
	    [ -d ~/.ssh2/hostkeys ] &&
	      khd=( ${khd[@]} ~/.ssh2/hostkeys/*pub )
	fi

	# If we have known_hosts files to use
	if [ ${#kh[@]} -gt 0 -o ${#khd[@]} -gt 0 ]; then
	    # Escape slashes and dots in paths for awk
	    cur=${cur//\//\\\/}
	    cur=${cur//\./\\\.}
	    curd=$cur

	    if [[ "$cur" == [0-9]*.* ]]; then
		# Digits followed by a dot - just search for that
		cur="^$cur.*"
	    elif [[ "$cur" == [0-9]* ]]; then
		# Digits followed by no dot - search for digits followed
		# by a dot
		cur="^$cur.*\."
	    elif [ -z "$cur" ]; then
		# A blank - search for a dot or an alpha character
		cur="[a-z.]"
	    else
		cur="^$cur"
	    fi

	    if [ ${#kh[@]} -gt 0 ]; then

		# FS needs to look for a comma separated list
		COMPREPLY=( $( awk 'BEGIN {FS=","}
				{for (i=1; i<=2; ++i) { \
				       gsub(" .*$", "", $i); \
				       if ($i ~ /'$cur'/) {print $i} \
				}}' ${kh[@]} 2>/dev/null ) )
	    fi
	    if [ ${#khd[@]} -gt 0 ]; then
		# Needs to look for files called
		# .../.ssh2/key_22_<hostname>.pub
		# dont fork any processes, because in a cluster environment, 
		# there can be hundreds of hostkeys
		for i in ${khd[@]} ; do
		    if [[ "$i" == *key_22_$curd*.pub ]] && [ -r "$i" ] ; then
			host=${i/#*key_22_/}
			host=${host/%.pub/}
			COMPREPLY=( ${COMPREPLY[@]} $host )
		    fi
		done
	    fi
	    # append any available aliases from config files
	    if [ ${#config[@]} -gt 0 ] && [ -n "$aliases" ]; then
		hosts=$( compgen -W "$( sed -ne 's/^[Hh][Oo][Ss][Tt]['"$'\t '"']*\([^*?]*\)$/\1/p' ${config[@]} )" -- $ocur )
		COMPREPLY=( ${COMPREPLY[@]} $hosts )
	    fi

	    # apply suffix
	    for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
		COMPREPLY[i]=$user${COMPREPLY[i]}$suffix
	    done
	else
	    # Just do normal hostname completion
	    COMPREPLY=( $( compgen -A hostname -S "$suffix" -- $cur ) )
	fi

	return 0
}
complete -F _known_hosts traceroute traceroute6 tracepath tracepath6 \
	ping fping telnet host nslookup rsh rlogin ftp dig ssh-installkeys mtr

# This meta-cd function observes the CDPATH variable, so that cd additionally
# completes on directories under those specified in CDPATH.
#
_cd()
{
	local IFS=$'\t\n' cur=${COMP_WORDS[COMP_CWORD]} i j k

	# try to allow variable completion
	if [[ "$cur" == ?(\\)\$* ]]; then
		COMPREPLY=( $( compgen -v -P '$' -- "${cur#?(\\)$}" ) )
		return 0
	fi

	# Use standard dir completion if no CDPATH or parameter starts with /,
	# ./ or ../
	if [ -z "${CDPATH:-}" ] || [[ "$cur" == ?(.)?(.)/* ]]; then
		_filedir -d
		return 0
	fi

	local -r mark_dirs=$(_rl_enabled mark-directories && echo y)
	local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y)

	# we have a CDPATH, so loop on its contents
	for i in ${CDPATH//:/$'\t'}; do
		# create an array of matched subdirs
		k=${#COMPREPLY[@]}
		for j in $( compgen -d $i/$cur ); do
			if [[ ( $mark_symdirs && -h $j || $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
				j="${j}/"
			fi
			COMPREPLY[k++]=${j#$i/}
		done
	done

	_filedir -d

	if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
	    i=${COMPREPLY[0]}
	    if [ "$i" == "$cur" ] && [[ $i != "*/" ]]; then
		COMPREPLY[0]="${i}/"
	    fi
	fi
	    
	return 0
}
if shopt -q cdable_vars; then
    complete -v -F _cd $nospace $filenames cd
else
    complete -F _cd $nospace $filenames cd
fi

# A meta-command completion function for commands like sudo(8), which need to
# first complete on a command, then complete according to that command's own
# completion definition - currently not quite foolproof (e.g. mount and umount
# don't work properly), but still quite useful.
#
_command()
{
	local cur func cline cspec noglob cmd done i \
	      _COMMAND_FUNC _COMMAND_FUNC_ARGS

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	# If the the first arguments following our meta-command-invoker are
	# switches, get rid of them. Most definitely not foolproof.
	done=
	while [ -z $done ] ; do
	cmd=${COMP_WORDS[1]}
	    if [[ "$cmd" == -* ]] ; then
		for (( i=1 ; i<=COMP_CWORD ; i++)) ; do
		    COMP_WORDS[i]=${COMP_WORDS[i+1]}
		done
		COMP_CWORD=$(($COMP_CWORD-1))
	    else 
		done=1
	    fi
	done

	if [ $COMP_CWORD -eq 1 ]; then
		COMPREPLY=( $( compgen -c -- $cur ) )
	elif complete -p $cmd &>/dev/null; then
		cspec=$( complete -p $cmd )
		if [ "${cspec#* -F }" != "$cspec" ]; then
			# complete -F <function>
			#
			# COMP_CWORD and COMP_WORDS() are not read-only,
			# so we can set them before handing off to regular
			# completion routine

			# set current token number to 1 less than now
			COMP_CWORD=$(( $COMP_CWORD - 1 ))

			# get function name
			func=${cspec#*-F }
			func=${func%% *}
			# get current command line minus initial command
			cline="${COMP_LINE#*( )$1 }"
			# save noglob state
		      	shopt -qo noglob; noglob=$?
			# turn on noglob, as things like 'sudo ls *<Tab>'
			# don't work otherwise
		  	shopt -so noglob
			# split current command line tokens into array
			COMP_WORDS=( $cline )
			# reset noglob if necessary
			[ $noglob -eq 1 ] && shopt -uo noglob
			$func $cline
			# This is needed in case user finished entering
			# command and pressed tab (e.g. sudo ls <Tab>)
			COMP_CWORD=$(( $COMP_CWORD > 0 ? $COMP_CWORD : 1 ))
			cur=${COMP_WORDS[COMP_CWORD]}
			_COMMAND_FUNC=$func
			_COMMAND_FUNC_ARGS=( $cmd $2 $3 )
			COMP_LINE=$cline
			COMP_POINT=$(( ${COMP_POINT} - ${#1} - 1 ))
			$func $cmd $2 $3
			# remove any \: generated by a command that doesn't
			# default to filenames or dirnames (e.g. sudo chown)
			if [ "${cspec#*-o }" != "$cspec" ]; then
				cspec=${cspec#*-o }
				cspec=${cspec%% *}
				if [[ "$cspec" != @(dir|file)names ]]; then
					COMPREPLY=("${COMPREPLY[@]//\\\\:/:}")
				fi
			fi
		elif [ -n "$cspec" ]; then
			cspec=${cspec#complete};
			cspec=${cspec%%$cmd};
			COMPREPLY=( $( eval compgen "$cspec" -- "$cur" ) );
		fi
	fi

	[ ${#COMPREPLY[@]} -eq 0 ] && _filedir
}
complete -F _command $filenames nohup exec nice eval strace time ltrace then \
	else do vsound command xargs

_root_command()
{
	PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin _command $1 $2 $3
}
complete -F _root_command $filenames sudo fakeroot really

have nslookup &&
_nslookup()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]#-}

	COMPREPLY=( $( compgen -P '-' -W 'all class= debug d2 domain= \
			       srchlist= defname search port= querytype= \
			       type= recurse retry root timeout vc \
			       ignoretc' -- $cur ) )
} &&
complete -F _nslookup nslookup

_longopt()
{
	local cur opt

	cur=${COMP_WORDS[COMP_CWORD]}

	if [[ "$cur" == --*=* ]]; then
		opt=${cur%%=*}
		# cut backslash that gets inserted before '=' sign
		opt=${opt%\\*}
		cur=${cur#*=}
		_filedir
		COMPREPLY=( $( compgen -P "$opt=" -W '${COMPREPLY[@]}' -- $cur))
		return 0
	fi

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( $1 --help 2>&1 | sed -e '/--/!d' \
				-e 's/.*\(--[-A-Za-z0-9]\+=\?\).*/\1/' | \
			       command grep "^$cur" | sort -u ) )
	elif [[ "$1" == @(mk|rm)dir ]]; then
		_filedir -d
	else
		_filedir
	fi
}
# makeinfo and texi2dvi are defined elsewhere.
for i in a2ps autoconf automake bc gprof ld nm objcopy objdump readelf strip \
	 bison cpio diff patch enscript cp df dir du ln ls mkfifo mknod mv rm \
	 touch vdir awk gperf grep grub indent less m4 sed shar date \
	 tee who texindex cat csplit cut expand fmt fold head \
	 md5sum nl od paste pr ptx sha1sum sort split tac tail tr unexpand \
	 uniq wc ldd bash id irb mkdir rmdir; do
  have $i && complete -F _longopt $filenames $i
done

# These commands use filenames, so '-o filenames' is not needed.
for i in env netstat seq uname units wget; do
  have $i && complete -F _longopt $default $i
done
unset i

# gcc(1) completion
#
# The only unusual feature is that we don't parse "gcc --help -v" output
# directly, because that would include the options of all the other backend
# tools (linker, assembler, preprocessor, etc) without any indication that
# you cannot feed such options to the gcc driver directly.  (For example, the
# linker takes a -z option, but you must type -Wl,-z for gcc.)  Instead, we
# ask the driver ("g++") for the name of the compiler ("cc1"), and parse the
# --help output of the compiler.
#
have gcc &&
_gcc()
{
	local cur cc backend

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	_expand || return 0

	case "$1" in
	gcj)
		backend=jc1
		;;
	gpc)
		backend=gpc1
		;;
	*77)
		backend=f771
		;;
	*)
		backend=cc1	# (near-)universal backend
		;;
	esac

	if [[ "$cur" == -* ]]; then
		cc=$( $1 -print-prog-name=$backend )
		# sink stderr:
		# for C/C++/ObjectiveC it's useless
		# for FORTRAN/Java it's an error
		COMPREPLY=( $( $cc --help 2>/dev/null | tr '\t' ' ' | \
			       sed -e '/^  *-/!d' -e 's/ *-\([^ ]*\).*/-\1/' | \
			       command grep "^$cur" | sort -u ) )
	else
		_filedir
	fi
} &&
complete $filenames -F _gcc gcc g++ c++ g77 gcj gpc
[ $UNAME = GNU -o $UNAME = Linux -o $UNAME = Cygwin ] && \
[ -n "${have:-}" ] && complete $filenames -F _gcc cc

# Linux cardctl(8) completion
#
have cardctl &&
_cardctl()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [ $COMP_CWORD -eq 1 ]; then
		COMPREPLY=( $( compgen -W 'status config ident suspend \
					   resume reset eject insert scheme' \
			       -- $cur ) )
	fi
} &&
complete -F _cardctl cardctl

# This function is required by _dpkg() and _dpkg-reconfigure()
#
have dpkg && {
have grep-status && {
_comp_dpkg_installed_packages()
{
	grep-status -P -e "^$1" -a -FStatus 'install ok installed' -n -s Package
}
} || {
_comp_dpkg_installed_packages()
{
	grep -A 2 "Package: $1" /var/lib/dpkg/status | \
		grep -B 2 'ok installed' | grep "Package: $1" | cut -d\  -f2
}
}

# Debian dpkg(8) completion
#
_dpkg()
{
	local cur prev i

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}
	i=$COMP_CWORD

	_expand || return 0

	# find the last option flag
	if [[ $cur != -* ]]; then
		while [[ $prev != -* && $i != 1 ]]; do
			i=$((i-1))
			prev=${COMP_WORDS[i-1]}
		done
	fi

	case "$prev" in 
	-@(c|i|A|I|f|e|x|X|-@(install|unpack|record-avail|contents|info| \
			  fsys-tarfile|field|control|extract)))
		_filedir '?(u)deb'
		return 0
		;;
	-@(b|-build))
		_filedir -d
		return 0
		;;
   	-@(s|p|l|-@(status|print-avail|list)))
		COMPREPLY=( $( apt-cache pkgnames $cur 2>/dev/null ) )
		return 0
		;;
	-@(S|-search))
		_filedir
		return 0
		;;
	-@(r|L|P|-@(remove|purge|listfiles)))
		COMPREPLY=( $( _comp_dpkg_installed_packages $cur ) )
		return 0
		;;
	*)

	COMPREPLY=( $( compgen -W '-i --install --unpack -A --record-avail \
			--configure -r --remove -P --purge --get-selections \
			--set-selections --update-avail --merge-avail \
			--clear-avail  --command-fd --forget-old-unavail -s \
			--status -p --print-avail -L --listfiles -l --list \
			-S --search -C --audit --print-architecture \
			--print-gnu-build-architecture \
			--print-installation-architecture \
			--compare-versions --help --version --force-help \
			--force-all --force-auto-select --force-downgrade \
			--force-configure-any --force-hold --force-bad-path \
			--force-not-root --force-overwrite \
			--force-overwrite-diverted --force-bad-verify \
			--force-depends-version --force-depends \
			--force-confnew --force-confold --force-confdef \
			--force-confmiss --force-conflicts --force-architecture\
			--force-overwrite-dir --force-remove-reinstreq \
			--force-remove-essential -Dh \
			--debug=help --licence --admindir= --root= --instdir= \
			-O --selected-only -E --skip-same-version \
			-G --refuse-downgrade -B --auto-deconfigure \
			--no-debsig --no-act -D --debug= --status-fd \
			-b --build -I --info -f --field -c --contents \
			-x --extract -X --vextract --fsys-tarfile -e --control \
			--ignore-depends= --abort-after' -- $cur ) )
		;;
	esac


}
complete -F _dpkg $filenames dpkg dpkg-deb
}

# Debian GNU dpkg-reconfigure(8) completion
#
have dpkg-reconfigure &&
_dpkg_reconfigure()
{
	local cur prev opt

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}


	case "$prev" in
	    -@(f|-frontend))
		opt=( $( echo /usr/share/perl5/Debconf/FrontEnd/* ) )
		opt=( ${opt[@]##*/} )
		opt=( ${opt[@]%.pm} )
		COMPREPLY=( $( compgen -W '${opt[@]}' -- $cur ) )
		return 0
		;;
	    -@(p|-priority))
  		COMPREPLY=( $( compgen -W 'low medium high critical' -- $cur ) )
		return 0
		;;
	esac

	if [[ "$cur" == -* ]]; then
	    COMPREPLY=( $( compgen -W '-f --frontend -p --priority -a --all \
				       -u --unseen-only -h --help -s --showold \
				       --force --terse' -- $cur ) )
	else
	    COMPREPLY=( $( _comp_dpkg_installed_packages $cur ) )
	fi
} &&
complete -F _dpkg_reconfigure $default dpkg-reconfigure

# Debian dpkg-source completion
#
have dpkg-source &&
_dpkg_source()
{
	local cur prev options work i action packopts unpackopts

	packopts="-c -l -F -V -T -D -U -W -E -sa -i -I -sk -sp -su -sr -ss -sn -sA -sK -sP -sU -sR"
	unpackopts="-sp -sn -su"
	options=`echo "-x -b $packopts $unpackopts" | xargs echo | sort -u | xargs echo`

	COMPREPLY=()
	if [ "$1" != "dpkg-source" ]; then
		exit 1
	fi
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}
	action="options"
	for (( i=0; i < ${#COMP_WORDS[@]}-1; i++ )); do
		if [[ ${COMP_WORDS[$i]} == "-x" ]]; then
			action=unpack
		elif [[ ${COMP_WORDS[$i]} == "-b" ]]; then
			action=pack
		elif [[ ${COMP_WORDS[$i]} == "-h" ]]; then
			action=help
		fi
	done
	# if currently seeing a complete option, return just itself.
	for i in $options; do
		if [ "$cur" = "$i" ]; then
			COMPREPLY=( "$cur" )
			return 0
		fi
	done
	case "$action" in
		"unpack")
			if [ "$cur" = "-" -o "$cur" = "-s" ]; then
				COMPREPLY=( $unpackots )
				return 0
			fi
			case "$prev" in
				"-x")
					COMPREPLY=( $( compgen -d -- "$cur" ) \
						    $( compgen -f -X '!*.dsc' -- "$cur" ) )
					return 0
					;;
				*)
					COMPREPLY=( $unpackopts $(compgen -d -f -- "$cur" ) )
					return 0
					;;
			esac
			return 0
			;;
		"pack")
			if [ "$cur" = "-" ]; then
				COMPREPLY=( $packopts )
				return 0
			fi
			if [ "$cur" = "-s" ]; then
				COMPREPLY=( "-sa" "-sk" "-sp" "-su" "-sr" "-ss" "-sn" \
			    		"-sA" "-sK" "-sP" "-sU" "-sR" )
				return 0
			fi
			case "$prev" in
				"-b")
					COMPREPLY=( $( compgen -d -- "$cur" ) )
					return 0
					;;
				"-c"|"-l"|"-T"|"-i"|"-I")
					# -c: get controlfile
					# -l: get per-version info from this file
					# -T: read variables here, not debian/substvars
					# -i: <regexp> filter out files to ignore diffs of.
					# -I: filter out files when building tarballs.
					# return directory names and file names
					COMPREPLY=( $( compgen -d -f ) )
					return 0
					;;
				"-F")
					# -F: force change log format
					COMPREPLY=( $( ( cd /usr/lib/dpkg/parsechangelog; compgen -f "$cur" ) ) )
					return 0
					;;
				"-V"|"-D")
					# -V: set a substitution variable
					# we don't know anything about possible variables or values
					# so we don't try to suggest any completion.
					COMPREPLY=()
					return 0
					;;
				"-D")
					# -D: override or add a .dsc field and value
					# if $cur doesn't contain a = yet, suggest variable names
					if echo -- "$cur" | grep -q "="; then
						# $cur contains a "="
						COMPREPLY=()
						return 0
					else
						COMPREPLY=( Format Source Version Binary Maintainer Uploader Architecture Standards-Version Build-Depends Files )
						return 0
					fi
					;;
				"-U")
					# -U: remove a field
					# Suggest possible fieldnames
					COMPREPLY=( Format Source Version Binary Maintainer Uploader Architecture Standards-Version Build-Depends Files )
					return 0
					;;
				*)
					COMPREPLY=( $packopts )
					return 0
					;;
			esac
			return 0
			;;
		*)
			# if seeing a partial option, return possible completions.
			if [ "$cur" = "-s" ]; then
				COMPREPLY=( "-sa" "-sk" "-sp" "-su" "-sr" "-ss" "-sn" \
			    		"-sA" "-sK" "-sP" "-sU" "-sR" )
				return 0
			fi
			# else return all possible options.
			COMPREPLY=( $options )
			return 0
			;;
	esac
} &&
complete -F _dpkg_source dpkg-source

# Debian Linux dselect(8) completion.
#
have dselect &&
_dselect()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
	     --admindir)
		  _filedir -d
		  return 0
		  ;;

	     -@(D|debug))
		  _filedir
		  return 0
		  ;;
	esac

	if [[ "$cur" == -* ]]; then
	    COMPREPLY=( $( compgen -W '--admindir --help --version --licence \
				  --license --expert --debug' -- $cur ) )
	else
	    COMPREPLY=( $( compgen -W 'access update select install config \
				  remove quit' -- $cur ) )
	fi


	return 0
} &&
complete -F _dselect $filenames dselect

# PINE address-book completion
#
have pine &&
_pineaddr()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	COMPREPLY=( $( compgen -W '$( awk "{print \$1}" ~/.addressbook 2>/dev/null)' \
			-- $cur ) )
} &&
complete -F _pineaddr $default pine

# mutt completion
#
# Mutt doesn't have an "addressbook" like Pine, but it has aliases and
# a "query" function to retrieve addresses, so that's what we use here.
have mutt || have muttng && {
_muttaddr()
{
	_muttaliases
	_muttquery
	return 0
}

_muttconffiles()
{
	local file sofar
	local -a newconffiles

	sofar=" $1 "
	shift
	while [[ "$1" ]]; do
	    newconffiles=( $(sed -rn 's|^source[[:space:]]+([^[:space:]]+).*$|\1|p' $(eval echo $1) ) )
	    for file in ${newconffiles[@]}; do
		[[ ! "$file" ]] || [[ "${sofar/ ${file} / }" != "$sofar" ]] &&
		    continue
		sofar="$sofar $file"
		sofar=" $(eval _muttconffiles \"$sofar\" $file) "
	    done
	    shift
	done
	echo $sofar
}

_muttaliases()
{
	local cur muttrc
	local -a conffiles aliases
	cur=${COMP_WORDS[COMP_CWORD]}

	[ -f ~/.${muttcmd}/${muttcmd}rc ] && muttrc="~/.${muttcmd}/${muttcmd}rc"
	[ -f ~/.${muttcmd}rc ] && muttrc="~/.${muttcmd}rc"
	[ -z "$muttrc" ] && return 0

	conffiles=( $(eval _muttconffiles $muttrc $muttrc) )
	aliases=( $( sed -rn 's|^alias[[:space:]]+([^[:space:]]+).*$|\1|p' \
			$(eval echo ${conffiles[@]}) ) )
	COMPREPLY=( ${COMPREPLY[@]} $( compgen -W "${aliases[*]}" -- $cur ) )

	return 0
}

_muttquery()
{
	local cur querycmd
	local -a queryresults
	cur=${COMP_WORDS[COMP_CWORD]}

	querycmd="$( $muttcmd -Q query_command  | sed -r 's|^query_command=\"(.*)\"$|\1|; s|%s|'$cur'|' )"
	if [ -z "$cur" -o -z "$querycmd" ]; then
	    queryresults=()
	else 
	    queryresults=( $( $querycmd | \
	      sed -nr '2,$s|^([^[:space:]]+).*|\1|p' ) )
	fi

	COMPREPLY=( ${COMPREPLY[@]} $( compgen -W "${queryresults[*]}" \
			-- $cur ) )

	return 0
}

_muttfiledir()
{
	local cur folder spoolfile
	cur=${COMP_WORDS[COMP_CWORD]}

	# This is currently not working so well. Perhaps this function should
	# just call _filedir() for the moment.
	if [[ $cur == [=+]* ]]; then
		folder="$( $muttcmd -Q folder | sed -r 's|^folder=\"(.*)\"$|\1|' )"
		: folder:=~/Mail

		# Match any file in $folder beginning with $cur
		# (minus the leading '=' sign).
		COMPREPLY=( $( compgen -f -- "$folder/${cur:1}" ) )
		COMPREPLY=( ${COMPREPLY[@]#$folder/} )
		return 0
	elif [ "$cur" == !* ]; then
		spoolfile="$( $muttcmd -Q spoolfile | sed -r 's|^spoolfile=\"(.*)\"$|\1|' )"
		[ ! -z "$spoolfile" ] && eval cur="${cur/^!/$spoolfile}";
	fi
	_filedir

	return 0
}

_mutt()
{
	local cur prev
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	COMPREPLY=()
	
	[ ${COMP_WORDS[0]} == muttng ] && muttcmd="muttng" || muttcmd="mutt"

	case "$cur" in
	-*)
		COMPREPLY=( $( compgen -W '-A -a -b -c -e -f -F -H -i -m -n \
					    -p -Q -R -s -v -x -y -z -Z -h' \
					    -- $cur ) )
		return 0
		;;
	*)
	    case "$prev" in
	    -@(a|f|F|H|i))
		    _muttfiledir
		    return 0
		    ;;
	    -A)
		    _muttaliases
		    return 0
		    ;;
	    -@(e|m|Q|s|h|p|R|v|y|z|Z))
		    return 0
		    ;;
	    *)
		    _muttaddr
		    return 0
		    ;;
	    esac
	    ;;
	esac
	
}
complete -F _mutt $default $filenames mutt muttng
}

_configure_func()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	# if $COMP_CONFIGURE_HINTS is not null, then completions of the form
	# --option=SETTING will include 'SETTING' as a contextual hint
	[[ "$cur" != -* ]] && return 0

	if [ -n "$COMP_CONFIGURE_HINTS" ]; then
		COMPREPLY=( $( $1 --help | awk '/^  --[A-Za-z]/ { print $1; if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,].*//g' | grep ^$cur ) )

	else
		COMPREPLY=( $( $1 --help | awk '/^  --[A-Za-z]/ { print $1; if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,=].*//g' | grep ^$cur ) )
	fi
}
complete -F _configure_func $default configure

# Debian reportbug(1) completion
#
have reportbug &&
_reportbug()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
	    -f|--filename|-i|--include|--mta|-o|--output)
		_filedir
		return 0
		;;
	    -B|--bts)
		COMPREPLY=( $( compgen -W "debian guug kde mandrake help" -- \
			       $cur ))
		return 0
		;;
	    -e|--editor|--mua)
		COMP_WORDS=(COMP_WORDS[0] $cur)
		COMP_CWORD=1
		_command
		return 0
		;;
	    --mode)
		COMPREPLY=( $( compgen -W "novice standard expert" -- $cur ) )
		return 0
		;;
	    -S|--severity)
		COMPREPLY=( $( compgen -W "grave serious important normal \
					   minor wishlist" -- $cur ) )
		return 0
		;;
	    -u|--ui|--interface)
		COMPREPLY=( $( compgen -W "newt text gnome" -- $cur ) )
		return 0
		;;
	    -t|--type)
		COMPREPLY=( $( compgen -W "gnats debbugs" -- $cur ) )
		return 0
		;;
	    -T|--tags)
		COMPREPLY=( $( compgen -W "none patch security upstream sid \
					   woody potato sarge fixed" -- $cur ))
		return 0
		;;
	    *)
		;;
	esac
	
	COMPREPLY=($( compgen -W '-h --help -v --version -a --af -b \
			--no-query-bts --query-bts -B --bts -c --configure \
			--no-config-files --check-available -d --debug \
			--no-check-available -e --editor --email -f \
			--filename -g --gnupg -H --header -i --include -j \
			--justification -l --ldap --no-ldap -L --list-cc -m \
			--maintonly --mode --mua --mta --mutt -n --mh --nmh \
			-o --output -p --print -P --pgp --proxy --http_proxy\
			-q --quiet -Q --query-only --realname --report-quiet \
			--reply-to --replyto -s --subject -S --severity \
			--smtphost -t --type -T --tags --template -V -x \
			--no-cc --package-version -z --no-compress \
			--ui --interface -u \
			wnpp boot-floppies kernel-image' -- $cur ) \
	    		$( apt-cache pkgnames -- $cur ) )
	_filedir
	return 0
} &&
complete -F _reportbug $filenames reportbug

# links completion
#
have links &&
_links()
{
	local cur
  
	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
  
	case "$cur" in
	    --*)
		COMPREPLY=( $( compgen -W '--help' -- $cur ) )
		;;
	    -*)
		COMPREPLY=( $( compgen -W '-async-dns -max-connections \
				-max-connections-to-host -retries \
				-receive-timeout -unrestartable-receive-timeout\
				-format-cache-size -memory-cache-size \
				-http-proxy -ftp-proxy -download-dir \
				-assume-codepage -anonymous -dump -no-connect \
				-source -version -help' -- $cur ) )
		;;
	    *)
		if [ -r ~/.links/links.his ]; then
		    COMPREPLY=( $( compgen -W '$( < ~/.links/links.his )' \
				   -- $cur ) )
		fi
				_filedir '@(htm|html)'
				return 0
		;;
	esac
  
	return 0
} &&
complete -F _links $filenames links

[ $UNAME = FreeBSD ] && {
# FreeBSD package management tool completion
#
_pkg_delete()
{
	local cur pkgdir prev

	pkgdir=${PKG_DBDIR:-/var/db/pkg}/
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	[ "$prev" = "-o" -o "$prev" = "-p" -o "$prev" = "-W" ] && return 0

	COMPREPLY=( $( compgen -d $pkgdir$cur ) )
	COMPREPLY=( ${COMPREPLY[@]#$pkgdir} )

	return 0
}
complete -F _pkg_delete $dirnames pkg_delete pkg_info
have pkg_deinstall && complete -F _pkg_delete $dirnames pkg_deinstall

# FreeBSD kernel module commands
#
_kldload()
{
	local cur moddir

	moddir=/modules/
	[ -d $moddir ] || moddir=/boot/kernel/
	cur=${COMP_WORDS[COMP_CWORD]}

	COMPREPLY=( $( compgen -f $moddir$cur ) )
	COMPREPLY=( ${COMPREPLY[@]#$moddir} )
	COMPREPLY=( ${COMPREPLY[@]%.ko} )

	return 0
}
complete -F _kldload $filenames kldload

_kldunload()
{
	local cur
	cur=${COMP_WORDS[COMP_CWORD]}
	COMPREPLY=( $(kldstat | sed -ne "s/^.*[ \t]\+\($cur[a-z_]\+\).ko$/\1/p") )
}
complete -F _kldunload $filenames kldunload
}

# FreeBSD portupgrade completion
#
have portupgrade &&
_portupgrade()
{
	local cur pkgdir prev

	pkgdir=${PKG_DBDIR:-/var/db/pkg}/
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	[ "$prev" = "-l" -o "$prev" = "-L" -o "$prev" = "-o" ] && return 0

	COMPREPLY=( $( compgen -d $pkgdir$cur ) )
	COMPREPLY=( ${COMPREPLY[@]#$pkgdir} )
	COMPREPLY=( ${COMPREPLY[@]%-*} )

	return 0
} &&
complete -F _portupgrade $dirnames portupgrade

# FreeBSD portinstall completion
#
have portinstall &&
_portinstall()
{
	local cur portsdir prev indexfile
	local -a COMPREPLY2

	portsdir=${PORTSDIR:-/usr/ports}/
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}
	# First try INDEX-5
	indexfile=$portsdir/INDEX-5
	# Then INDEX if INDEX-5 does not exist or system is not FreeBSD 5.x
	[ "${OSTYPE%.*}" = "freebsd5" -a -f $indexfile ] ||
	  indexfile=$portsdir/INDEX

	[ "$prev" = "-l" -o "$prev" = "-L" -o "$prev" = "-o" ] && return 0

	COMPREPLY=( $( egrep "^$cur" < $indexfile | cut -d'|' -f1 ) )
	COMPREPLY2=( $( egrep "^[^\|]+\|$portsdir$cur" < $indexfile | \
			cut -d'|' -f2 ) )
	COMPREPLY2=( ${COMPREPLY2[@]#$portsdir} )
	COMPREPLY=( ${COMPREPLY[@]} ${COMPREPLY2[@]} )

	return 0
} &&
complete -F _portinstall $dirnames portinstall

# Slackware Linux removepkg completion
#
have removepkg && [ -f /etc/slackware-version ] &&
_removepkg()
{
	local packages cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	COMPREPLY=( $( (cd /var/log/packages; compgen -f -- "$cur") ) )
} &&
complete -F _removepkg $filenames removepkg &&
	complete $dirnames -f -X '!*.tgz' installpkg upgradepkg explodepkg

# look(1) completion
#
have look && 
_look()
{
	local cur
  
	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [ $COMP_CWORD = 1 ]; then
		COMPREPLY=( $( compgen -W '$(look $cur)' ) )
	fi
} &&
complete -F _look $default look

# aspell(1) completion
#
have aspell && {
_aspell_dictionary()
{
	local datadir
	datadir=/usr/lib/aspell
	COMPREPLY=( $( command ls $datadir/*.@(multi|alias) ) )
	COMPREPLY=( ${COMPREPLY[@]%.@(multi|alias)} )
	COMPREPLY=( $( compgen -W '${COMPREPLY[@]#$datadir/}' -- $cur ) )
}

_aspell()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	# --name value style option
	case "$prev" in
		@(-c|-p|check))
			_filedir
			return 0
			;;
		@(dump|create|merge))
			COMPREPLY=( $( compgen -W 'master personal repl' -- $cur ) )
			return 0
			;;
		-d)
			_aspell_dictionary
			return 0
			;;
	esac

	# --name=value style option
	if [[ "$cur" == *=* ]]; then
		prev=${cur/=*/}
		cur=${cur/*=/}
		case "$prev" in
			--@(conf|personal|repl|per-conf))
				_filedir
				return 0
				;;
			--@(conf-dir|data-dir|dict-dir|home-dir|local-data-dir|prefix))
				_filedir -d
				return 0
				;;
			--master)
				_aspell_dictionary
				return 0
				;;
			--mode)
				COMPREPLY=( $( compgen -W 'none url email sgml tex' -- $cur ) )
				return 0
				;; 
			--sug-mode)
				COMPREPLY=( $( compgen -W 'ultra fast normal bad-speller' -- $cur ) )
				return 0
				;;
			--keymapping)
				COMPREPLY=( $( compgen -W 'aspell ispell' -- $cur ) )
				return 0
				;;
		esac
	fi

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '--conf= --conf-dir= --data-dir= --dict-dir= \
			--encoding= --add-filter= --rem-filter= --mode= -e \
			-H -t --add-extra-dicts= --rem-extra-dicts= \
			--home-dir= -W --ignore= --ignore-accents \
			--dont-ignore-accents --ignore-case --dont-ignore-case \
			--ignore-repl --dont-ignore-repl --jargon= --keyboard= \
			--lang= --language-tag= --local-data-dir= -d --master= \
			--module= --add-module-search-order= \
			--rem-module-search-order= --per-conf= -p --personal= \
			--prefix= --repl= -C -B --run-together --dont-run-together \
			--run-together-limit= --run-together-min= --save-repl \
			--dont-save-repl --set-prefix --dont-set-prefix --size= \
			--spelling= --strip-accents --dont-strip-accents \
			--sug-mode= --add-word-list-path= --rem-word-list-path= \
			-b -x --backup -b|-x --dont-backup --reverse --dont-reverse \
			--time --dont-time --keymapping= --add-email-quote= \
			--rem-email-quote= --email-margin= --add-tex-command= \
			--rem-tex-command= --tex-check-comments \
			--dont-tex-check-comments --add-tex-extension= \
			--rem-tex-extension= --add-sgml-check= --rem-sgml-check= \
			--add-sgml-extension= --rem-sgml-extension=' -- $cur ) )
	else
		COMPREPLY=( $( compgen -W '-? help -c check -a pipe -l list \
			config config soundslike filter -v version dump \
			create merge' -- $cur ) )
	fi

}
complete -F _aspell $default aspell
}

# xmms(1) completion
#
have xmms &&
_xmms()
{
	local cur

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-h --help -r --rew -p --play \
			-u --pause -s --stop -t --play-pause -f --fwd -e \
			--enqueue -m --show-main-window -i --sm-client-id \
			-v --version' -- $cur ) )
	else
		_filedir '@(mp[23]|MP[23]|ogg|OGG|wav|WAV|pls|m3u|xm|mod|s[3t]m|it|mtm|ult|flac)'

	fi

} &&
complete -F _xmms $filenames xmms

# info(1) completion
#
have info &&
_info()
{
	local cur infopath UNAME

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	_expand || return 0

	# default completion if parameter contains /
	if [[ "$cur" == */* ]]; then
		_filedir
		return 0
	fi

	infopath='/usr/share/info'

	if [ "${INFOPATH: -1:1}" == ':' ]; then
		infopath=${INFOPATH}${infopath}
	elif [ ${INFOPATH:+set} ]; then
		infopath=$INFOPATH
	fi

	infopath=$infopath:
	if [ -n "$cur" ]; then
		infopath="${infopath//://$cur* }"
	else
		infopath="${infopath//:// }"
	fi

	# redirect stderr for when path doesn't exist
	COMPREPLY=( $( eval command ls "$infopath" 2>/dev/null ) )
	# weed out directory path names and paths to info pages
	COMPREPLY=( ${COMPREPLY[@]##*/?(:)} )
	# weed out info dir file
	for (( i=0 ; i < ${#COMPREPLY[@]} ; ++i )); do
		if [ "${COMPREPLY[$i]}" == 'dir' ]; then
			unset COMPREPLY[$i];
		fi;
	done  
	# strip suffix from info pages
	COMPREPLY=( ${COMPREPLY[@]%.@(gz|bz2)} )
	COMPREPLY=( $( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ) )

	return 0
} &&
complete -F _info $filenames info

# dhclient(1) completion
#
have dhclient && _dhclient()
{
	local cur prev

	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	case "$prev" in
		-@(cf|lf|pf|sf))
			_filedir
			return 0
			;;
		-s)
			_known_hosts
			return 0
			;;
	esac

	if [[ "$cur" == -* ]]; then
		COMPREPLY=( $( compgen -W '-p -d -q -1 -r -lf -pf \
			-cf -sf -s -g -n -nw -w' -- $cur ) )
	else
		_available_interfaces
	fi
} &&
complete -F _dhclient dhclient

_filedir_xspec()
{
	local IFS cur xspec

	IFS=$'\t\n'
	COMPREPLY=()
	cur=${COMP_WORDS[COMP_CWORD]}

	_expand || return 0

	# get first exclusion compspec that matches this command
	xspec=$( sed -ne $'/^complete .*[ \t]'${1##*/}$'\([ \t]\|$\)/{p;q;}' \
		  $BASH_COMPLETION )
	# prune to leave nothing but the -X spec
	xspec=${xspec#*-X }
	xspec=${xspec%% *}

	COMPREPLY=( $( eval compgen -f -X "$xspec" -- \
		    \"${cur#[\`\"\']}\" 2>/dev/null ) \
		    $( compgen -d -- $cur ) )
}
list=( $( sed -ne '/^# START exclude/,/^# FINISH exclude/p' \
	  $BASH_COMPLETION | \
	# read exclusion compspecs
	(
	while read line
	do
		# ignore compspecs that are commented out
		if [ "${line#\#}" != "$line" ]; then continue; fi
		line=${line%# START exclude*}
		line=${line%# FINISH exclude*}
		line=${line##*\'}
		list=( ${list[@]:-} $line )
	done
	echo ${list[@]}
	)
     ) )
# remove previous compspecs
if [ ${#list[@]} -gt 0 ]; then
    eval complete -r ${list[@]}
    # install new compspecs
    eval complete -F _filedir_xspec $filenames ${list[@]}
fi
unset list

# source completion directory definitions
if [ -d $BASH_COMPLETION_DIR -a -r $BASH_COMPLETION_DIR -a \
     -x $BASH_COMPLETION_DIR ]; then
	for i in $BASH_COMPLETION_DIR/*; do
		[[ ${i##*/} != @(*~|*.bak|*.swp|\#*\#|*.dpkg*|.rpm*) ]] &&
			[ \( -f $i -o -h $i \) -a -r $i ] && . $i
	done
fi
unset i

# source user completion file
[ $BASH_COMPLETION != ~/.bash_completion -a -r ~/.bash_completion ] \
	&& . ~/.bash_completion
unset -f have
unset UNAME RELEASE default dirnames filenames have nospace bashdefault \
      plusdirs

###  Local Variables:
###  mode: shell-script
###  End:
